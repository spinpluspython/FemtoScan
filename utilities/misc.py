# -*- coding: utf-8 -*-
"""

@author: Steinn Ymir Agustsson

    Copyright (C) 2018 Steinn Ymir Agustsson, Vladimir Grigorev

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""
import sys, os
from configparser import ConfigParser


def my_exception_hook(exctype, value, traceback):
    # Print the error and traceback
    print(exctype, value, traceback)
    # Call the normal Exception hook after
    sys._excepthook(exctype, value, traceback)
    sys.exit(1)


def nested_for(ranges, operation, *args, **kwargs):
    """this is some magic iteration script. it creates a nested for loop
    :parameters:
        ranges: tuple of tuples
            define the ranges of the loops. each tuple creates a loop with range(tuple[0],tuple[1])
        operation:
            the operation to be performed
        *args:
            passed to operation
        **kwargs:
            passed to operation
    """
    from operator import mul
    from functools import reduce
    operations = reduce(mul, (p[1] - p[0] for p in ranges)) - 1
    indexes = [i[0] for i in ranges]
    pos = len(ranges) - 1
    increments = 0

    operation(indexes, *args, **kwargs)
    while increments < operations:
        if indexes[pos] == ranges[pos][1] - 1:
            indexes[pos] = ranges[pos][0]
            pos -= 1
        else:
            indexes[pos] += 1
            increments += 1
            pos = len(ranges) - 1  # increment the innermost loop
            operation(indexes, *args, **kwargs)


def iterate_ranges(ranges):
    """this is some magic iteration script. it creates a nested for loop
    :parameters:
        ranges: tuple of tuples
            define the ranges of the loops. each tuple creates a loop with range(tuple[0],tuple[1])
        operation:
            the operation to be performed
        *args:
            passed to operation
        **kwargs:
            passed to operation
    """
    from operator import mul
    from functools import reduce
    operations = reduce(mul, (p[1] - p[0] for p in ranges)) - 1
    indexes = [i[0] for i in ranges]
    pos = len(ranges) - 1
    increments = 0

    yield (ranges)
    while increments < operations:
        if indexes[pos] == ranges[pos][1] - 1:
            indexes[pos] = ranges[pos][0]
            pos -= 1
        else:
            indexes[pos] += 1
            increments += 1
            pos = len(ranges) - 1  # increment the innermost loop
            yield (ranges)

def parse_setting(category,name, settings_file='default'):
    """ parse setting file and return desired value

    Args:
        category (str): title of the category
        name (str): name of the parameter
        setting_file (str): path to setting file. If set to 'default' it takes
            a file called SETTINGS.ini in the main folder of the repo.

    Returns:
        value of the parameter, None if parameter cannot be found.
    """
    settings = ConfigParser()
    if settings_file == 'default':
        current_path = os.path.dirname(__file__)
        while not os.path.isfile(os.path.join(current_path,'SETTINGS.ini')):
            current_path = os.path.split(current_path)[0]

        settings_file = os.path.join(current_path,'SETTINGS.ini')
    settings.read(settings_file)
    try:
        value = settings[category][name]
        return value
    except KeyError:
        print('No entry "{}" in category "{}" found in SETTINGS.ini'.format(name,category))
        return None




class TwoWayDict(dict):
    """dictionary which can be read as key: val or val: key."""

    def __setitem__(self, key, value):
        # Remove any previous connections with these values
        if key in self:
            del self[key]
        if value in self:
            del self[value]
        dict.__setitem__(self, key, value)
        dict.__setitem__(self, value, key)

    def __delitem__(self, key):
        dict.__delitem__(self, self[key])
        dict.__delitem__(self, key)

    def __len__(self):
        """Returns the number of connections"""
        return dict.__len__(self) // 2




def main():
    pass


if __name__ == '__main__':
    from utilities.misc import my_exception_hook
    # used to see errors generated by PyQt5 in pycharm:
    sys._excepthook = sys.excepthook
    # Set the exception hook to our wrapping function
    sys.excepthook = my_exception_hook
    main()
